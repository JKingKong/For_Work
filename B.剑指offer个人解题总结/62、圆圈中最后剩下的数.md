# 48、孩子们的游戏(圆圈中最后剩下的数)

## 题目描述

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1

## 1、暴力模拟

### 1.解题思路

1. 直接模拟整个过程
   1. 循环：
      1. 该位置的孩子没有出圈,才能报数 （孩子已经出圈，则不允许报数）
         1. 报数操作
         2. 报数为 m - 1时孩子出圈
         3. count == 0时返回index
      2. 孩子编号自增操作

### 2.代码

```java
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(n < 1 || m < 1) return -1;
        if(m == 1) return n - 1;
        int[] child = new int[n]; //初始全0
        int count = n; // 孩子数
        int index = 0; // 孩子编号
        int num = 0;   // 报数
        while(count > 0){
            if(child[index] == 0){// 该位置的孩子没有出圈,才能报数
                // 报数
                if(num == m - 1){
                    count--; 
                    if(count == 0) return index;
                    child[index] = -1;
                }
                // 报数+1
                num++;
                num = num % m;
            }
            // 不论允不允许报数，孩子编号都要+1
            index++;
            index = index % n;
        }
        return index;
    }
}
```

### 3.复杂度

* 时间复杂度：O(n*m)

* 空间复杂度：O(n)

### 4.遇到的坑

- 

## 2、找规律--递归

### 1.解题思路

把n个人的编号改为0~n-1，然后对删除的过程进行分析。

1. 第一个删除的数字是(m-1)%n，编号为：k。

2. 剩余的编号为(0,1,...,k-1,k+1,...,n-1)

3. 下次开始删除时顺序为(k+1,...,n-1,0,1,...k-1)。

   1. 用f(n,m)表示从(0~n-1)开始删除后的最终结果
   2. 用q(n-1,m)表示从(k+1,...,n-1,0,1,...k-1)开始删除后的最终结果 
   3. 则f(n,m) = q(n-1,m) （第一个出圈的人肯定不是胜利者）

4. 下面把(k+1,...,n-1,0,1,...k-1)转换为(0~n-2)的形式

   * | 原始 | 映射后 |
     | ---- | ------ |
     | k+1  | 0      |
     | k+2  | 1      |
     | ...  | ...    |
     | n-1  | n-k-2  |
     | 0    | n-k-1  |
     | 1    | n-k    |
     | ...  | ...    |
     | k-1  | n-2    |

     (当x = n-1时，  映射=(n-1)  - (k+1) = n - k - 1 , 即：映射——x - k - 1 )

     **映射函数**设为  $p(x) = (x - k - 1) \bmod n$     （从原始--->映射后）

     **逆映射函数:**    $p ^ {-1}(x) = (x + k + 1) \bmod n$   （从映射后--->原始）

   * ```java
     f(n, m) = q(n - 1, m) 
         	= p ^ (f(n - 1, m)) 
        f(n, m) 	= (f(n - 1, m) + k + 1) % n   (1)
     因为：
     	k = (m - 1) % n  带入(1) 得：
     	f(n, m) = (f(n - 1, m) + (m - 1) % n + 1) % n 
     	(？？？怎么化简的？？？？？？？？)(使用mod运算的结合律化简)
     	f(n, m) = (f(n - 1, m) + m) % n;
     ```

5. 最终的递推关系式为：

   * ```java
     f(1, m) = 0                        (n = 1)
     f(n, m) = (f(n - 1, m) + m) % n    (n > 1)
     ```

     

### 2.代码

```java

```

### 3.复杂度

- 时间复杂度：O( )
- 空间复杂度：O( )

### 4.遇到的坑

- 

