# 34、把数组排成最小的数

## 题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

## 1、暴力法

### 1.解题思路

1. 穷尽数组里元素的组合
   1. 每个组合得到一个字符串，并且保存起来
2. 大数处理，字符串--->整数，取其中最小的

### 2.代码

```java

```

### 3.复杂度

- 时间复杂度：O( )
- 空间复杂度：O( )

### 4.遇到的坑

- 

## 2、排序法

### 1.解题思路

分析：

1. 无论怎样组合，得到的数的位数一定是固定的

2. 而得到的数的位数固定，那么如果尽量使组合出来的数的高位较小，便可能得到小的数

3. **详细过程：** **（此过程是错误的）**

   - 最高位和最低位：
     - 只有个位的数，最低位和最高位都是他们本身
       - 如：1--9中的 **9**，最高位：**9**，最低位：**9**
     - **10**，最高位：1，最低位：0
     - **225**，最高位：2，最低位：5

   1. 找数组中的**“最小的数”**
      1. 找数组中**最高位**最小的数
         1. 如果存在多个数的**最高位相同**
            1. 比较这几个数的次高位，取次高位最小的数
            2. 若有多个数的次高位相同，则继续往下找**次次高位**，直到找到唯一一个
               - 如：111 和 1112
               - 前三位都相同，最后找到1112
            3. 而后
   2. 当某个数字被找出就与字符串相连，就从数组中排除，而后继续执行 1，直到所有数都被拼起来

   

   **正确方法：**

   ​	  **自定义一个比较大小的函数，比较两个字符串s1, s2大小的时候，先将它们拼接起来，比较s1+s2,和s2+s1那个大，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面**

   **问题最终转化成：**

   1. 将数组中所有int整数都分别转换成字符串，并且存入一个ArrayList<String> list中

   2. 对 list 进行字符串“由小到大排序”

      1. 由**小到大排序规则**：
         1. 从list中取字符串**s1，s2**
         2. 比较规则：(**s1+s2**).compareTo(**s2 + s1**)  **（满足了上边高位、次高、低位等比较规则）**
            1. s1+s2 < s2 + s1（返回值== - 1： 需要反序操作）
            2. s1+s2 > s2 + s1（返回值== 1：不需要反序操作，保持原有顺序）

      例子：

      - 例子： 一个字符串数组： s2，s1
      - (**s1+s2**).compareTo(**s2 + s1**)        （**字符串比较的compareTo（）方法需要详细了解**）
      - (**s1+s2**) < (**s2 + s1**)  返回 -1，需要进行反序操作，从而：数组变成：s1，s2
      - s1+s2 > s2 + s1（返回值== 1：不需要反序操作，保持原有顺序）数组：s2，s1

   3. 将排序后的ArrayList<String>所有String元素从左到右连接起来

**证明：为什么这样排个序就可以了呢？**

简单证明一下。

1. 如果s1+s2 < s2+s1，则排序为：s1，s2   否则：s2，s1。

2. 可利用反证法---**假设**:

   1. 排成的**最小数字**为xxxxxx，并且至少存在一对字符串满足这个关系：**s1+s2 > s2+s1**，**但是**在组成的数字中**s1排在s2前面**。根据**s1和s2出现的位置**，**分三种情况考虑**：

3. 证明：

   1. xxxxs1s2，用s2s1代替s1s2可以得到xxxxs2s1，这个数字是**小于**xxxxs1s2，**与假设矛盾**。因此排成的最小数字中，**不存在上述假设的关系**。

   2. s1s2xxxx，用s2s1代替s1s2可以得到s2s1xxxx，这个数字是**小于**s1s2xxxx，**与假设矛盾**。因此排成的最小数字中，**不存在上述假设的关系**

   3. s1xxxxs2，这一步证明麻烦了一点。可以将**中间部分**看成一个**整体y**

      * 则：**s1ys2**，则有**s1y < ys1**，**ys2 < s2y**成立。将s1y和s2y表示成10进制数字形式，则有下述关系式，这里s1，y，s2的位数分别为n，m，k

      1. $s1y < ys1   $
         1. $==>  s1 * 10^{m} + y < y* 10^{n} + s1$
         2. $==> s1 * 10^{m} -s1  < y* 10^{n} - y$
         3. $==> s1 * \frac{10^{m} - 1}{10^{n} - 1} < y$
      2.  $ys2 < s2y $
         1. $==>  y * 10^{k} + s2 < s2* 10^{m} + y$
         2. $ ==> y * 10^{k} - y< s2* 10^{m} - s2 $
         3. $ ==> y < s2* \frac{10^{m} - 1}{10^{k} - 1}$
      3.  $s1 * \frac{10^{m} - 1}{10^{n} - 1} < y <  s2* \frac{10^{m} - 1}{10^{k} - 1}$    (由1、2与y的关系得到的)
         1. $==>  \frac{s1}{10^{n} - 1} < \frac{s2}{10^{k} - 1}$
         2. $==>  s1 * 10^{k} -s1 < s2 * 10^{n} - s2$
         3. $==> s1*10^{k} + s2 < s2 * 10^{n} + s1$
         4. $==> s1 < s2$
      4.    由上边第3步证得：**s1 < s2**，这**与假设s1 > s2矛盾**。因此排成的最小数字中，**不存在上述假设的关系**。

   4. **综上所述**，得出**假设不成立**，从而得出**结论**：对于排成的最小数字，**不存在**满足下述关系的一对字符串：**s1 + s2 > s2 + s1**，**但是**在组成的数字中**s1出现在s2的前面**。从而得出算法是正确的。 

### 2.代码

```java
import java.util.Arrays;

public class Solution {
    public String PrintMinNumber(int[] numbers) {
        if (numbers == null || numbers.length == 0)
            return "";
        int n = numbers.length;
        String[] nums = new String[n];
        for (int i = 0; i < n; i++)
            nums[i] = numbers[i] + "";  // 数字转换成字符串
        Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1)); //定义比较规则
        StringBuilder ret =  new StringBuilder();  //带缓冲的字符串连接器
        for (String str : nums)	
            ret.append(str); 	//字符串连接起来
        return ret.toString();
    }
}
```

### 3.复杂度

- 时间复杂度：O(nlogn * m)   
- 空间复杂度：O(n)

### 4.遇到的坑

- 想到了连接字符串，没有想到排序
- 还有证明为什么可以这样排序也没有证明出来

