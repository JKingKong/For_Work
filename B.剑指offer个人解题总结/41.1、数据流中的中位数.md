# 数据流中的中位数

## 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。
  

## 1、暴力模拟

### 1.解题思路

1. 排序

2. 判断数组长度

   1. len == 1

   2. len > 2

      1. 奇数，取mid = len/2

         1. middle = a[mid]

      2. 偶数，index1 = len/2 - 1   index2 = len/2

         1. middle = ( a[index1] + a[index2] )/2

         ​			

         

### 2.代码

```java

```

### 3.复杂度

- 时间复杂度：O( )
- 空间复杂度：O( )

### 4.遇到的坑

- 




## 2、双优先队列法

### 1.解题思路

[参考](https://sunweiguo.github.io/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9863-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%91/)

1. 先用java集合`PriorityQueue`来设置一个小顶堆和大顶堆

2. 主要的思想是：因为要求的是中位数，那么这两个堆，

   1. **大顶堆用来存较小的数，从大到小排列（即：等价于存放排序后的后半部分的数）**；
   2. **小顶堆存较大的数，从小到大的顺序排序（即：等价于存放排序后的后半部分的数）**，显然中位数就是大顶堆的根节点与小顶堆的根节点和的平均数。

3. ⭐保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值

4. ⭐当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；

5. ⭐当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；

6. ⭐取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；如果当前个数为奇数，显然是取小顶堆的根节点

   理解了上面所述的主体思想，下面举个例子辅助验证一下。

   例如，传入的数据为：[5,2,3,4,1,6,7,0,8],那么按照要求，输出是"5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "

   那么整个程序的执行流程应该是（用min表示小顶堆，max表示大顶堆）：

   - 5先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[5],max=[无]，avg=[5.00]
   - 2先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[5],max=[2],avg=[(5+2)/2]=[3.50]
   - 3先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[3,5],max=[2],avg=[3.00]
   - 4先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[4,5],max=[3,2],avg=[(4+3)/2]=[3.50]
   - 1先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[3,4,5],max=[2,1]，avg=[3/00]
   - 6先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，此时min=[4,5,6],max=[3,2,1],avg=[(4+3)/2]=[3.50]
   - 7先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，此时min=[4,5,6,7],max=[3,2,1],avg=[4]=[4.00]
   - 0先进入小顶堆，然后将小顶堆中最大值放入小顶堆中，此时min=[4,5,6,7],max=[3,2,1,0],avg=[(4+3)/2]=[3.50]
   - 8先进入大顶堆，然后将大顶堆中最小值放入大顶堆中，此时min=[4,5,6,7,8],max=[3,2,1,0],avg=[4.00]

### 2.代码

```java
import java.util.PriorityQueue;
public class Solution {
    /* 大顶堆，存储左半边元素 */
    private PriorityQueue<Integer> left = new PriorityQueue<>((o1, o2) -> o2 - o1);
    /* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */
    private PriorityQueue<Integer> right = new PriorityQueue<>();
    /* 当前数据流读入的元素个数 */
    private int N = 0;

    public void Insert(Integer num) {
        if(N % 2 == 0){
		/* N 为偶数的情况下插入到左半边。
         * 因为左半边元素都要小于右半边，但是新插入的元素不一定比右半边元素来的小，
         * 因此需要先将元素插入右半边，然后利用右半边为大顶堆的特点，取出堆顶元素即为			最大元素，此时插入左半边
         *  保证：1.左半边元素都要小于右半边
         *       2.前半部分数的个数 + 1 == 后半部分数的个数 
         */
            right.add(num);
            left.add(right.poll());
        }else{
            left.add(num);
            right.add(left.poll());
        }
        N++;
    }
    public Double GetMedian() {
        if(N % 2 == 0){
            return (left.peek() + right.peek()) / 2.0;
        }else{
            // 元素个数为奇数时，取前半部分最大值
            // 即：前半部分数的个数 + 1 == 后半部分数的个数 
            return (double) left.peek();  
        }
    }


}
```

### 3.复杂度

- 从N个数建立两个堆操作的时间复杂度：O(n)   
- 从N个数建立两个堆操作的空间复杂度：O(n)
- 若从数据流中插入一个新的数
  - 插入堆的时间复杂度：O(logn)
  - 查找中位数的时间复杂度：O(1)

### 4.遇到的坑

- 
- 