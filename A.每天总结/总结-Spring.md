Spring总结
	配置
		使用maven来配置
		问题
			版本冲突
			版本匹配问题
	IOC
		原理
			工厂模式解耦
			反射机制
			配置约定
		作用
			控制反转
			解耦
			专注于业务
			减少重复编码
			减少new创建对象
		获取容器实例的几种方法
			通过绝对路径
			通过classpath的方法
			通过注解
		生成Bean实例
			构造器
				默认构造器
				构造器带参数
			工厂方法
（使用人写的类的时候一般会这样）
				静态工厂方法
				工厂方法
			通过注解
				@Component
				@Controller
				@Service
				@Repository
		bean的生命周期
			初始化方法
			销毁方法
		注入
			XML
				构造器注入
				setter注入（常用）
			注解
				启动扫描
				常用注解（区别、作用要知道）
					创建对象
						@Component
						@Controller
						@Service
						@Repository
					数据注入
						@Value
						@Autowired
							默认按照类型注入
							多个同类型则报错
						@Qualifier
						@Resource
							默认先按照名称注入，找不到则按照类型注入
					改变作用范围
						@Scope
					生命周期相关
						@PostConstruct（初始化方法）
						@PreDestroy（销毁方法）
		配置
			半注解配置
				包扫描声明（扫描注解）
			纯注解配置（需要的）
				新建容器指明配置类
				注解
					@Configuration
					@ComponentScan
						注解排除规则
						类排除规则
						多重@ComponentScan
						自定以扫描规则
							实现TypeFilter 接口
					@Bean
					@PropertySource
					@Import
	AOP
		AOP相关术语
			Joinpoint(连接点)
			Pointcut(切入点)
			Advice(通知/增强)
			Weaving(织入)
			Aspect(切面)
		解除耦合
			业务层和持久层耦合
			业务层方法冗余、臃肿
			解决代码重复、冗余问题
			解决项目维护问题
			代码功能增强
		AOP的原理
			动态代理
			两种动态代理方式
				官方Proxy类
				第三方CGLib库
		两种使用方式
			XML
				1、增加XML的aop约束
				2、配置通知类
				3、<aop:config>标签
				4、<aop:aspect>标签
					id
					ref
				5、<aop:pointcut>标签
					id
					expression
				6、通知类型
					属性
						method
						poinitcut
						ponitcut-ref
					类型
						<aop:before>
						<aop:after-returning>
						<aop:after-throwing>
						<aop:after>
						<aop:around>
				切点表达式
					通配符使用规则
			注解
				导入XML约束支持
				要在xml配置文件中开启支持AOP注解
				@Aspect
指明通知类
				配置通知类
					注解标明切点表达式
					注解标明通知方法
						@Before
						@AfterReturning
						@AfterThrowing
						@After
						@Around
							注意这个怎么编写
				执行顺序有问题
（使用注解配置AOP的bug）
					使用环绕通知解决
	整合Junit
		注解
			写在类上
				@RunWith(SpringJUnit4ClassRunner.class)
				@ContextConfiguration(locations= {"classpath:bean.xml"})
			写在方法上
				@Test
		Spring容器导入问题
			使用spring提供的jar包
			注解
	jdbcTemplate
		抽取重复代码
			继承
				xml
				别人的库
			注解
				自己写的
		1、配置数据源
			数据源的种类
				C3P0数据源
				DBCP数据源
				Spring内置数据源
			导入数据源所需参数
				使用xml
				使用注解
					@PropertySource("classpath:jdbc.properties")	
// 指定配置文件的路径,关键字classpath表示类路径
		2、创建JdbcTempalte对象
		3、JdbcTemplate的增删查改操作
		4、JdbcTemplate实现查询操作
		5、抽取重复代码（导入JdbcTemplate对象）
			使用注解
			使用继承+XML配置
	事务控制
		XML声明式事务控制（很好用）
		半注解式事务控制（还行）
		纯注解式事务控制（不是很好）
		编程式事务控制(不推荐，基本不会用到)
		Spring 事务管理 API
		Spring 编程式事务管理
			基于底层 API 的编程式事务管理
			基于 TransactionTemplate 的编程式事务管理
		Spring 声明式事务管理
			基于 <tx> 命名空间的声明式事务管理  （XML）
			基于 @Transactional 的声明式事务管理
	事务
		自己实现一个事务管理方式---
			使用动态代理
			使用AOP
		Spring内置的管理器
			XML声明式事务管理
				推荐
				可以使用通配符
				步骤
					1、配置数据源
					2、配置 事务管理器 并且注入数据源
					3、配置 事务通知 并且在通知中配置其属性
						<tx:advice>
							id
							transaction-manager
							<tx:attributes>
								<tx:method>
									name
									isolation
									propagation
									read-only
									timeout
									rollback-for
									no-rollback-for
					4、配置AOP并为事务通知指定切入点
			半注解式事务管理
				不是很推荐，没有通配符，还是要自己去写注解
				步骤
					1、配置数据源
					2、配置 事务管理器 并且注入数据源
					3、在业务层使用@Transactional注解,其参数与<tx:method>的属性一致
						@Transactional
							对接口加上,表示对该接口的所有实现类进行事务控制
							对类加上,表示对类中的所有方法进行事务控制
							对方法加上,表示对具体方法进行事务控制
			纯注解式事务管理
				步骤
					1、配置数据源
					2、配置 事务管理器 并且注入数据源
					3、在业务层使用@Transactional注解,其参数与<tx:method>的属性一致
						@Transactional
							对接口加上,表示对该接口的所有实现类进行事务控制
							对类加上,表示对类中的所有方法进行事务控制
							对方法加上,表示对具体方法进行事务控制
					

			编程式事务管理
				本质还是动态代理
				不推荐使用，麻烦，重复代码多，每多写一个事务都要多写代码